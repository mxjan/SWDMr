---
title: "Examples"
author: Maxime Jan
date: 12 August 2019
output:
  md_document:
    variant: markdown_github
---

# Package

load packages

```{r}
library(SWDMr)
library(optimx)
library(ggplot2)
library(doSNOW)
```

# Prepare data

Sleep-wake data per hour

```{r}
# Data
# ****** Prepare Sleep-Wake data ****** 
files <- list.files(path="../Data/BXD_SleepWake_SDMJ2018/",pattern = paste("^","BL6",sep=""),full.names = T)
SWdf<-Read_SW(files,concattimesec = 360) # 300 = 5min, 180 = 3 min, 360 = 6min
SWdf<-SWdf_AddLD(SWdf) # Add Light and Dark
SWdf<-SWdf_DayMerging(SWdf,Daysformat=list(c(1,2),c(1,2),3,4,c(1,2)),concattimesec=360)
SWdf<-SWdf_AddSD(SWdf,c(48,54))
head(SWdf)
```

Explained variable is gene expression

```{r}
# ***** Prepare Gene expression data ******
# Gene expression
#load("../Data/C57BL6J_Cortex_TimeCourse_CHN2019/CHN2019_TimeCourse_NormalizedData_Genes.RData")
load("../Data/C57BL6J_Liver_TimeCourse_MJCHN2020/B6Liver_FilePrepSWDMr.Rdata")
```

# Run fitting

Build swdmr object

```{r}
## If you want a greater timestep for Rk4
# SWdf<-SWdf[rep(seq_len(nrow(SWdf)), each = 10), ]
# SWdf$Time<-seq(0.01,120.0,by=0.01)
```


```{r}
swdmr <- SWDMr(SWdist=SWdf, Gexp=rna_expr)
swdmr
```

Initiate a Driven Damped Harmonic Oscillator [DDHO] model for a gene

```{r}
Gene<-"Hnmt"
model<-initDDHOmodel(swdmr,VarExp = Gene)
```

Set some parameter of our model

```{r}
# Mean expression in baseline between highest and lowest value
MeanPerTime<-aggregate(rna_expr[rna_meta$SD_NSD == "NSD",Gene],list(rna_meta$Time[rna_meta$SD_NSD == "NSD"]),mean)
MeanGeneExprInBaseline<-(max(MeanPerTime$x)+min(MeanPerTime$x))/2

# Fix the intercepts
model<-FixIntercept(model,MeanGeneExprInBaseline)
# Add sleep-wake force
model<-AddForce(model,"Wake")
model<-AddForce(model,"Sleep")

# Start is set at intercept with speed of 0
model<-SetYinitMode(model,mode = "Intercept_0",values = c(0,48))
# We replicate baseline for 20 day
model<-ReplicateDrivingForce(model,c(0,24.0),40)
# A sin-wave force is applied with a period of 24h
model<-AddSinF(model,FixPer = 24)
# Compute the fit using RSS
model<-SetFittingValue(model,value = "RSS")
# Penalize the fitting for unstable value for 10 replicated days
model<-PenalizeUnstableFit(model,value = T,PredictedValueInterval = c(0,48), StabilityDayCheck = 10)


```

summary of the model

```{r}
model
```

Fit data with optimx

```{r}
# Get objective function
objfun<-SWDMrGetEvalFun(model)

# 1st Fit
params<-c(Wake=-0.1,Sleep=0.1,loggamma=log(1e-1),omega=2*pi/24,AmpSin=0,PhiSin=pi)
fits<-optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000))
params<-c(Wake=0.1,Sleep=-0.1,loggamma=log(1e-1),omega=2*pi/24,AmpSin=0,PhiSin=pi)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))
params<-c(Wake=0,Sleep=0,loggamma=log(1e-1),omega=2*pi/24,AmpSin=0.01,PhiSin=pi)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))
params<-c(Wake=0,Sleep=0,loggamma=log(1e-1),omega=2*pi/24,AmpSin=0.01,PhiSin=0)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))


# Overdamped fit
params<-c(Wake=-1,Sleep=1,loggamma=1,omega=2*pi/24,AmpSin=0,PhiSin=pi)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))
params<-c(Wake=1,Sleep=-1,loggamma=1,omega=2*pi/24,AmpSin=0,PhiSin=pi)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))
params<-c(Wake=0,Sleep=0,loggamma=1,omega=2*pi/24,AmpSin=0.01,PhiSin=pi)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))
params<-c(Wake=0,Sleep=0,loggamma=1,omega=2*pi/24,AmpSin=0.01,PhiSin=0)
fits<-rbind(fits, optimx(params,fn = objfun,method=c("nlminb"),control=list(maxit=1000)))

fits

if (! any(! is.na(fits$Wake))){
  params<-c(Wake=0,Sleep=0,loggamma=log(1e-1),omega=2*pi/24,AmpSin=0,PhiSin=pi)
  fits<-optimx(params,fn = objfun,method=c("newuoa"),control=list(maxit=10000))
}

if (any(fits$convcode == 0)){
  fits<-fits[fits$convcode == 0,,drop=F]
  optimxres<-fits[order(fits$value),,drop=F][1,]
}else{
  optimxres<-fits[order(fits$value),,drop=F][1,]
}

optimxres
```


Get fit

```{r}
out<-SWDMrFit(model,params = optimxres[1,])
par(mfrow=c(2,1))
plot(out$time,out$y1,type="l",ylab="Position",xlab="Time",xlim=c(0,120),xaxt="n")
axis(1,seq(0,120,by=12),seq(0,120,by=12))
plot(out$time,out$y2,type="l",xlab="Time",xlim=c(0,120),xaxt="n",ylab="RNA velocity",lwd=2)
axis(1,seq(0,120,by=12),seq(0,120,by=12))
```

Get some statistics for the fit (R2, and AdjR2 are not valid measure ! Do not use them !)

```{r}
SWDMrStats(model,out,detailed = T)$stats
```

Plot fit and gene expression using ggplot2

```{r}
SWDMr:::StandardFittingPlot(model,optimxres[1,])
```
## Process S Fit

```{r}
modelS<-initProcessSmodel(swdmr,VarExp = Gene)
modelS<-ReplicateDrivingForce(modelS,c(0,24.0),40)
modelS<-SetYinitMode(modelS,"Fixed",4.8)
```


```{r}
modelS
```

```{r}
objfun<-SWDMrGetEvalFun(modelS)
paramsS<-c("AsympWake"=6,AsympSleep=4,TauWake=10,TauSleep=10)
fitsS<-optimx(paramsS,fn = objfun,method=c("nlminb"),control=list(maxit=1000))

outS<-SWDMrFit(modelS,fits)
```


```{r}
SWDMr:::StandardFittingPlot(modelS,fitsS[1,])
```

```{r}
SWDMrStats(modelS,outS,detailed = T)$stats
```



Mean force applied by each force on the oscillator

```{r}
Fmod<-SWDMr:::AllForceApplied(model,optimxres)
sumF<-apply(abs(Fmod[,seq(2,6)]),1,sum)
Fmod[,seq(2,6)]<-abs(Fmod[,seq(2,6)])/sumF
apply(Fmod[Fmod$Time>48 & Fmod$Time < 72.1,],2,mean)
```

```{r}
optimx2<-optimxres[1,]
optimx2["AmpSin"]<-0
SWDMr:::StandardFittingPlot(model,optimx2)

optimx2<-optimxres[1,]
optimx2["omega"]<-2*pi/24
SWDMr:::StandardFittingPlot(model,optimx2)

optimx2<-optimxres[1,]
optimx2["Sleep"]<-0
optimx2["Wake"]<-0
SWDMr:::StandardFittingPlot(model,optimx2)
```




# Empirical bootstrap

Compute confidence interval using empirical bootstrap

```{r}
# See http://sia.webpopix.org/nonlinearRegression.html
EmpBoot<-function(model, optimxres, params, upper, lower, nboot = 100, NCORES = 7){
  
  out<-SWDMrFit(model,params = optimxres[1,])
  
  F <- matrix(nrow=nboot,ncol=length(out$y1))
  Y <- matrix(nrow=nboot,ncol=length(out$y1))
  
  pred<-SWDMrFit(model,params = optimxres[1,])
  predv<-pred$y1
  names(predv)<-pred$time
  predval<-predv[as.character(model@Gexp[,"Time"])]
  
  stats<-SWDMrStats(model,out,detailed = T)
  model2<-model
  
  paramsboot<-as.numeric(optimxres[1,names(params)])
  names(paramsboot)<-names(params)
  
  cl <- makeCluster(NCORES)
  #clusterExport(cl,c("lower","upper","model2","stats"))
  registerDoSNOW(cl)
  
  B <- foreach(i = 1:nboot,.packages=c("SWDMr","optimx"),.combine="rbind") %dopar% {
    n<-length(model2@Gexp[,1])
    model2@Gexp[,1]<- predval + sqrt(stats[["ErrorVariance"]])*rnorm(n)
    objfunboot<-SWDMrGetEvalFun(model2)
    #optimxresboot<-optimx(paramsboot,objfunboot,method=c("nlminb"),lower = lower,upper=upper)
    optimxresboot<-optimx(paramsboot,objfunboot,method=c("nlminb"))
    
    return(as.numeric(optimxresboot[1,names(params)]))
  }
  stopCluster(cl)
  
  for (l in 1:nrow(B)){
    bootpar<-B[l,]
    names(bootpar)<-names(params)
    outboot<-SWDMrFit(model,params = bootpar)
    F[l,] <- outboot$y1
    Y[l,] <- outboot$y1 + rnorm(1,0,sqrt(stats[["ErrorVariance"]]))
  }
  
  level <- 0.95
  alpha <- 1 - level
  df.mc<-data.frame(Time=out$time)
  df.mc[c("lwr.conf","upr.conf")] <- t(apply(F,MARGIN=2,function(x) quantile(x,c(alpha/2,1-alpha/2),na.rm=T)))
  df.mc[c("lwr.pred","upr.pred")] <- t(apply(Y,MARGIN=2,function(x) quantile(x,c(alpha/2,1-alpha/2),na.rm=T)))
  df.mc<-df.mc[df.mc$Time>0,]
  V.mc <- cov(B)
  
  se.mc <- sqrt(diag(V.mc))
  
  t.stat <- paramsboot/se.mc
  p.value <- 2*(1 - pt(abs(t.stat),51))
  
  Est.pvals<-cbind(Estimate=paramsboot,SE=se.mc,Tstat=t.stat,p.value)
  
  
  b <- c(apply(B,MARGIN=2,function(x) quantile(x,alpha/2,na.rm=T)),
         apply(B,MARGIN=2,function(x) quantile(x,1-alpha/2,na.rm=T)))
  ci.mc=matrix(b,ncol=2)
  row.names(ci.mc) <- names(paramsboot)
  colnames(ci.mc) <- c(paste0((1-level)/2*100,"%"),paste0((1+level)/2*100,"%"))

  return(list(B=B,Y=Y,F=F,CI=ci.mc,Est.pvals=Est.pvals,df.mc=df.mc))
}
```

Confidence intervals

```{r,eval=F}
EmpBootres<-EmpBoot(model,optimxres,params,upper,lower,nboot=200)
EmpBootres$CI
#EmpBootres$Est.pvals
```



```{r,eval=F}
p<-SWDMr:::StandardFittingPlot(model,optimxres[1,])
p <- p + annotate("ribbon",x=EmpBootres$df.mc$Time, ymin=EmpBootres$df.mc$lwr.pred, ymax=EmpBootres$df.mc$upr.pred, alpha=0.2, fill="blue")
p <- p + annotate("ribbon",x=EmpBootres$df.mc$Time, ymin=EmpBootres$df.mc$lwr.conf, ymax=EmpBootres$df.mc$upr.conf, alpha=0.4, fill="#339900")
p
```


```{r}
sessionInfo()
```

